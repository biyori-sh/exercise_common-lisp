(defun make-matrix (row col &key (initial-element 0.0))
  (make-array (list row col) :initial-element initial-element))

(defun make-id-matrix (order)
  (let ((m (make-array (list order order) :initial-element 0.0)))
    (dotimes (i order) (setf (aref m i i) 1.0))
    m))

(defun make-random-matrix (row col)
  (let ((m (make-array (list row col))))
    (dotimes (i row)
      (dotimes (j col) (setf (aref m i j) (random 1.0))))
    m))

(defun matrix-dimensions (m)
  (array-dimensions m))

(defun set-id-mat (m)
  (destructuring-bind (row col) (matrix-dimensions m)
    (dotimes (i row)
      (dotimes (j col)
	(setf (aref m i j) 0.0)))
    (dotimes (k (min row col)) (setf (aref m k k) 1.0))))

(defun copy-matrix (m)
  (destructuring-bind (row col) (matrix-dimensions m)
    (let ((mt (make-array (list row col))))
      (dotimes (i row)
	(dotimes (j col) (setf (aref mt i j) (aref m i j))))
      mt)))

(defun lud (m)
  (destructuring-bind (row col) (matrix-dimensions m)
    (when (= row col)
      (let ((l (make-id-matrix row))
	    (u (make-matrix row row))
	    (mt (copy-matrix m)))
	(labels ((lud-sub (ma ml mu index dim-1)
		   (if (>= index dim-1)
		       (progn (setf (aref mu dim-1 dim-1) (aref ma dim-1 dim-1))
			      (values ml mu))
		       (progn (setf (aref mu index index) (aref ma index index))
			      (dotimes (i (- dim-1 index))
				    (setf (aref mu index (+ index i 1))
					  (aref ma index (+ index i 1))))
			      (dotimes (i (- dim-1 index))
				(setf (aref ml (+ index i 1) index)
				      (/ (aref ma (+ index i 1) index)
					 (aref ma index index))))
			      (dotimes (i (- dim-1 index))
				(dotimes (j (- dim-1 index))
				  (decf (aref ma (+ index i 1) (+ index j 1))
					(/ (* (aref ma (+ index i 1) index)
					      (aref ma index (+ index j 1)))
					   (aref ma index index)))))
			      (lud-sub ma ml mu (1+ index) dim-1)))))
	  (lud-sub mt l u 0 (1- row)))))))
